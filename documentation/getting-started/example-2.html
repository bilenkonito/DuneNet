<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Displaying new connections | DuneNet </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Displaying new connections | DuneNet ">
    <meta name="generator" content="docfx 2.50.0.0">
    
    <link rel="shortcut icon" href="../../images/favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="displaying-new-connections">Displaying new connections</h1>

<h2 id="overview">Overview</h2>
<p>In the <a href="example-1.html">last example</a>, we learnt how to create a simple server and client and connect them together. However, we lacked any meaningful way to exploit that connection once it was established.<br>In this example, we will learn how to create two simple modules to print a message to the console when a new connection is established. 
This will require two additional classes that derive from <code>DuneModule</code>.</p>
<p>As in the last example, we will first provide the whole code for the example and then we will explain the important aspects of it.</p>
<p><em>Assets/Scripts/Server/Modules/ServerGreeter.cs:</em>  </p>
<pre><code class="lang-csharp">using DuneNet.Server;
using DuneNet.Shared;
using UnityEngine;

namespace Server.Modules
{
    public class ServerGreeter : DuneNet.Server.DuneModule
    {
        protected override void OnNetConnected(DuneConnection conn)
        {
            Debug.Log(&quot;A new client connected from: &quot; + conn.address);
        }
    }
}
</code></pre><p><em>Assets/Scripts/Client/Modules/ClientGreeter.cs:</em>  </p>
<pre><code class="lang-csharp">using DuneNet.Client;
using DuneNet.Shared;
using UnityEngine;

namespace Client.Modules
{
    public class ClientGreeter : DuneNet.Client.DuneModule
    {
        protected override void OnNetConnected(DuneConnection conn)
        {
            Debug.Log(&quot;Connected to server at: &quot; + conn.address);
        }

        protected override void OnHandshakeSuccessful(DuneConnection conn)
        {
            DuneClient.NetworkController.SetReady();
        }
    }
}
</code></pre><h2 id="servergreetercs">ServerGreeter.cs</h2>
<p>This module takes care of printing a message to the console whenever a client connects to the server. The message is printed before any kind of authentication is performed so we have no guarantee the client will stay connected after the authentication step. In future examples, we will dig down into the meaning of this concept but, for now, this message should allow us to verify that clients can, indeed, connect to our server.  </p>
<p>First of all, we define a new class that derives from <a href="../../api/DuneNet.Server.DuneModule.html"><code>DuneModule</code></a>:  </p>
<pre><code class="lang-csharp">public class ServerGreeter : DuneNet.Server.DuneModule
</code></pre><p>The <a href="../../api/DuneNet.Server.DuneModule.html"><code>DuneModule</code></a> class provides many overridable methods that we can use to extend the functionality of DuneNet beyond what the main controllers provide.<br>In our case, we want to override the  <code>OnNetConnected(DuneConnection conn)</code> method, which is automatically called when a new connection is established.  </p>
<pre><code class="lang-csharp">protected override void OnNetConnected(DuneConnection conn)
{
    Debug.Log(&quot;A new client connected from: &quot; + conn.address);
}
</code></pre><p>Here, we leverage the <code>address</code> property of <code>DuneConnection</code> to print a message to the console showing where the connection came from when a client connects to the server.</p>
<h2 id="clientgreetercs">ClientGreeter.cs</h2>
<p>This module takes care of printing a message to the console whenever the client connects to a server. The message is printed before any kind of authentication is performed so we have no guarantee that we will not be kicked by the server for not authenticating properly. In future examples, we will dig down into the meaning of this concept but, for now, this message should allow us to verify the client can, indeed, connect to a server.<br>The module also takes care of setting the client connection ready once the server has successfully authenticated the client.  </p>
<p>First of all, we define a new class that derives from <a href="../../api/DuneNet.Client.DuneModule.html"><code>DuneModule</code></a>:  </p>
<pre><code class="lang-csharp">public class ClientGreeter : DuneNet.Client.DuneModule
</code></pre><p>The <a href="../../api/DuneNet.Client.DuneModule.html"><code>DuneModule</code></a> class provides many overridable methods that we can use to extend the functionality of DuneNet beyond what the main controllers provide.<br>In our case, we want to override the  <code>OnNetConnected(DuneConnection conn)</code> and <code>OnHandshakeSuccessful(DuneConnection conn)</code> methods.<br>The <code>OnNetConnected(DuneConnection conn)</code> method is automatically called when a new connection is established, while the <code>OnHandshakeSuccessful(DuneConnection conn)</code> method is called when the server successfully authenticates the client.  </p>
<pre><code class="lang-csharp">protected override void OnNetConnected(DuneConnection conn)
{
    Debug.Log(&quot;Connected to server at: &quot; + conn.address);
}
</code></pre><p>Here, we leverage the <code>address</code> property of <code>DuneConnection</code> to print a message to the console showing the address of the server we just connected to.  </p>
<pre><code class="lang-csharp">protected override void OnHandshakeSuccessful(DuneConnection conn)
{
    DuneClient.NetworkController.SetReady();
}
</code></pre><p>Here, we set our connection ready once the server has authenticated the client. Setting the connection ready is only possible after the server has authenticated the client and instructs the server that we are ready to receive further information about the game state. This is useful, for example, to be able to change the client scene between the connection to the server and being able to receive game state updates.  </p>
<h2 id="registering-the-modules">Registering the modules</h2>
<p>Now that we have created both modules, we need to register them with DuneNet. This easily accomplished by using the <code>DunneClient.Use()</code> and <code>DuneServer.Use()</code> methods. Please, do note that only one instance of each module type can be registered at the same time.</p>
<p>For this example, we can simply modify the <code>ServerInit.cs</code> and <code>ClientInit.cs</code> classes from our <a href="example-1.html">last example</a>.</p>
<p><em>Assets/Scripts/Server/ServerInit.cs:</em>  </p>
<pre><code class="lang-csharp">using DuneNet.Server;
using UnityEngine;
using UnityEngine.Networking;

namespace Server
{
    public class ServerInit : DuneNet.Server.DuneMonoBehaviour
    {
        protected override void OnAwake()
        {
            DuneServer.Use(new ServerGreeter());

            DuneServer.NetworkController.Init(new GlobalConfig
            {
                MaxHosts = 20,
                MaxNetSimulatorTimeout = 12000,
                MaxPacketSize = 2000,
                MaxTimerTimeout = 12000,
                MinNetSimulatorTimeout = 1,
                ReactorMaximumReceivedMessages = 8092,
                ReactorMaximumSentMessages = 8092,
                ReactorModel = ReactorModel.SelectReactor,
                ThreadAwakeTimeout = 1,
                ThreadPoolSize = 1
            }, new ConnectionConfig
            {
                AckDelay = 33,
                AcksType = ConnectionAcksType.Acks32,
                AllCostTimeout = 20,
                BandwidthPeakFactor = 2,
                ConnectTimeout = 2000,
                DisconnectTimeout = 2000,
                FragmentSize = 500,
                InitialBandwidth = 0,
                MaxCombinedReliableMessageCount = 10,
                MaxCombinedReliableMessageSize = 100,
                MaxConnectionAttempt = 10,
                MaxSentMessageQueueSize = 896,
                MinUpdateTimeout = 10,
                NetworkDropThreshold = 5,
                OverflowDropThreshold = 5,
                PacketSize = 1440,
                PingTimeout = 500,
                ReducedPingTimeout = 100,
                ResendTimeout = 1200,
                SendDelay = 0,
                SSLCAFilePath = &quot;&quot;,
                SSLCertFilePath = &quot;&quot;,
                SSLPrivateKeyFilePath = &quot;&quot;,
                UdpSocketReceiveBufferMaxSize = 0,
                UsePlatformSpecificProtocols = false,
                WebSocketReceiveBufferMaxSize = 0
            }, 20);

            if (!DuneServer.NetworkController.Listen(&quot;127.0.0.1&quot;, 7000))
            {
                Debug.LogError(&quot;Error initializing network.&quot;);
            }
        }
    }
}  
</code></pre><p><em>Assets/Scripts/Client/ClientInit.cs:</em>  </p>
<pre><code class="lang-csharp">using DuneNet.Client;
using UnityEngine;
using UnityEngine.Networking;

namespace Client
{
    public class ClientInit : DuneNet.Client.DuneMonoBehaviour
    {
        protected override void OnAwake()
        {
            DuneClient.Use(new ClientGreeter());

            DuneClient.NetworkController.Init(new GlobalConfig
            {
                MaxHosts = 1,
                MaxNetSimulatorTimeout = 12000,
                MaxPacketSize = 2000,
                MaxTimerTimeout = 12000,
                MinNetSimulatorTimeout = 1,
                ReactorMaximumReceivedMessages = 8092,
                ReactorMaximumSentMessages = 8092,
                ReactorModel = ReactorModel.SelectReactor,
                ThreadAwakeTimeout = 1,
                ThreadPoolSize = 1
            }, new ConnectionConfig
            {
                AckDelay = 33,
                AcksType = ConnectionAcksType.Acks32,
                AllCostTimeout = 20,
                BandwidthPeakFactor = 2,
                ConnectTimeout = 2000,
                DisconnectTimeout = 2000,
                FragmentSize = 500,
                InitialBandwidth = 0,
                MaxCombinedReliableMessageCount = 10,
                MaxCombinedReliableMessageSize = 100,
                MaxConnectionAttempt = 10,
                MaxSentMessageQueueSize = 896,
                MinUpdateTimeout = 10,
                NetworkDropThreshold = 5,
                OverflowDropThreshold = 5,
                PacketSize = 1440,
                PingTimeout = 500,
                ReducedPingTimeout = 100,
                ResendTimeout = 1200,
                SendDelay = 0,
                SSLCAFilePath = &quot;&quot;,
                SSLCertFilePath = &quot;&quot;,
                SSLPrivateKeyFilePath = &quot;&quot;,
                UdpSocketReceiveBufferMaxSize = 0,
                UsePlatformSpecificProtocols = false,
                WebSocketReceiveBufferMaxSize = 0
            }, 20);

            if (!DuneClient.NetworkController.Connect(&quot;127.0.0.1&quot;, 7000))
            {
                Debug.LogError(&quot;Error initializing network.&quot;);
            }
        }
    }
}
</code></pre><h2 id="whats-next">What&#39;s next?</h2>
<p>Now that we can easily verify that the client can connect to the server, we should be able to start using more advanced features of DuneNet.<br>In the <a href="example-3.html">next example</a>, we will implement a basic authentication module to secure the server behind a password. </p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span class="footer-text">Copyright © 2018 Dune Interactive.
          </span></div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
